<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æ‹“æ‰‘å…³ç³»å¯è§†åŒ–å·¥å…·</title>
  <style>
    /* æ ·å¼ä¿æŒä¸å˜ */
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f7fa;
      color: #333;
    }

    .container {
      display: flex;
      flex-direction: column;
      max-width: 1600px;
      margin: 0 auto;
      background: white;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    header {
      background: #191548;
      color: white;
      padding: 20px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: 28px;
    }

    /* æ–°çš„é…ç½®åŒºåŸŸå¸ƒå±€ */
    .config-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 20px;
      background: #ecf0f1;
      border-bottom: 1px solid #ddd;
    }

    .config-panel {
      flex: 1;
      min-width: 300px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .power-config-panel {
      flex: 1;
      /* ä¿®æ”¹ä¸º1ä»½å®½åº¦ */
      min-width: 300px;
    }

    .convergence-config-panel {
      flex: 2;
      /* ä¿®æ”¹ä¸º2ä»½å®½åº¦ */
      min-width: 400px;
    }

    .control-group {
      margin-bottom: 15px;
    }

    h2 {
      font-size: 18px;
      margin-top: 0;
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 8px;
    }

    label {
      display: block;
      margin: 10px 0 5px;
      font-weight: 500;
    }

    select,
    input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      font-size: 14px;
    }

    /* åŠŸç‡èŠ‚ç‚¹é…ç½®å†…éƒ¨å¸ƒå±€ - ä¿®æ”¹ä¸ºå‚ç›´æ’åˆ— */
    .power-config-vertical {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    /* å¯è§†åŒ–åŒºåŸŸ */
    .visualization {
      padding: 20px;
      min-height: 350px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    canvas {
      background: rgba(173, 220, 241, 0.301);
      border: 1px solid #ddd;
      border-radius: 4px;
      max-width: 100%;
    }

    footer {
      text-align: center;
      padding: 15px;
      background: #f8f9fa;
      border-top: 1px solid #e9ecef;
      color: #191548;
      font-size: 14px;
    }

    .cross-connection-container {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }

    .cross-connection-select {
      width: 80px;
    }

    .plus-sign {
      font-size: 18px;
      font-weight: bold;
      color: #666;
    }

    .cross-connection-group {
      margin-bottom: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
      border: 1px solid #e9ecef;
    }

    /* å“åº”å¼è°ƒæ•´ */
    @media (max-width: 1200px) {
      .config-container {
        flex-direction: column;
      }

      .config-panel {
        min-width: 100%;
      }

      .power-config-vertical {
        flex-direction: column;
      }
    }

    /* è¾“å‡ºæŒ‰é’®æ ·å¼ */
    .output-button {
      background: #191548;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 15px;
      transition: background 0.3s;
    }

    .output-button:hover {
      background: #2980b9;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>åŠŸç‡èŠ‚ç‚¹æ‹“æ‰‘é…ç½®</h1>
    </header>

    <!-- é…ç½®åŒºåŸŸ - æ°´å¹³æ’åˆ— -->
    <div class="config-container">
      <div class="config-panel power-config-panel">
        <div class="control-group">
          <h2>åŠŸç‡èŠ‚ç‚¹é…ç½®</h2>
          <div class="power-config-vertical">
            <div>
              <label for="collectionCount">åŠŸç‡æ± æ•°é‡:</label>
              <select id="collectionCount">
                <option value="2">2</option>
                <option value="3" selected>3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
              </select>
            </div>
            <div>
              <label for="nodeSetPerCollection">åŠŸç‡èŠ‚ç‚¹æ•°é‡:</label>
              <select id="nodeSetPerCollection">
                <option value="2">2</option>
                <option value="3" selected>3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
              </select>
            </div>
            <div>
              <label for="nodesPerSet">èŠ‚ç‚¹è¿æ¥å™¨æ•°é‡:</label>
              <select id="nodesPerSet">
                <option value="3">3</option>
                <option value="4" selected>4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <div class="config-panel convergence-config-panel">
        <div class="control-group">
          <h2>æ±‡æµç‚¹è·¨æ¥é…ç½®</h2>
          <div id="crossConnectionContainer">
            <!-- åŠ¨æ€ç”Ÿæˆçš„è·¨æ¥é…ç½®åŒºåŸŸ -->
          </div>
        </div>
      </div>
    </div>

    <!-- å¯è§†åŒ–åŒºåŸŸ - åœ¨é…ç½®åŒºåŸŸä¸‹æ–¹ -->
    <div class="visualization">
      <canvas id="topologyCanvas" width="1600" height="550"></canvas>
    </div>

    <!-- è¾“å‡ºæŒ‰é’® -->
    <div style="padding: 20px 0; text-align: center; width: 100%">
      <button id="outputButton" class="output-button">
        ç”ŸæˆèŠ‚ç‚¹æ‹“æ‰‘ä»£ç 
      </button>
    </div>

    <footer>
      <p>åŠŸç‡èŠ‚ç‚¹æ‹“æ‰‘å¯è§†åŒ–å·¥å…· &copy; 2025 | è‹±é£æºæŠ€æœ¯æœ‰é™å…¬å¸</p>
    </footer>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const canvas = document.getElementById("topologyCanvas");
      const ctx = canvas.getContext("2d");
      const crossConnectionContainer = document.getElementById(
        "crossConnectionContainer"
      );
      const outputButton = document.getElementById("outputButton");

      // æ±‡æµç‚¹é¢œè‰² - æ™®é€šæ±‡æµç‚¹
      const convergenceColors = [
        "#e74c3c",
        "#2ecc71",
        "#f39c12",
        "#9b59b6",
        "#1abc9c",
        "#e67e22",
      ];

      // è·¨æ¥æ±‡æµç‚¹é¢œè‰² - ä½¿ç”¨ä¸åŒçš„é¢œè‰²
      const crossConnectionColors = [
        "#ff6b6b",
        "#48dbfb",
        "#feca57",
        "#ff9ff3",
        "#54a0ff",
        "#ff9f43",
      ];

      // è·¨æ¥é…ç½®çŠ¶æ€
      let crossConnections = [];

      // å…¨å±€å˜é‡å­˜å‚¨èŠ‚ç‚¹é›†åˆä¿¡æ¯
      let nodeSets = [];

      // å­˜å‚¨é‡æ–°ç¼–å·çš„æ˜ å°„å…³ç³»
      let renumberedPointsMap = {};

      // å­˜å‚¨æ±‡æµç‚¹ä¸å­èŠ‚ç‚¹çš„è¿æ¥å…³ç³»
      let convergenceConnections = [];

      // åˆå§‹åŒ–ç”»å¸ƒ
      function initCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "12px Arial";

        // æ·»åŠ æ°´å°
        ctx.fillStyle = "rgba(0, 0, 255, 0.03)"; // è“è‰²ï¼Œæ›´ä½çš„é€æ˜åº¦
        ctx.font = "bold 36px Arial";

        // è®¾ç½®æ°´å°é‡å¤çš„é—´è·
        const spacingX = 500;
        const spacingY = 120;

        // åœ¨æ•´ä¸ªç”»å¸ƒä¸Šé‡å¤ç»˜åˆ¶æ°´å°
        for (let x = 0; x < canvas.width; x += spacingX) {
          let cnt_y = 0;
          for (let y = 0; y < canvas.height; y += spacingY) {
            ctx.fillText(
              "è‹±é£æºInfyPower",
              x + (cnt_y++ % 2) * (spacingX / 2),
              y
            );
          }
        }
      }

      // ç”Ÿæˆæ‹“æ‰‘å›¾
      function generateTopology() {
        initCanvas();

        const collectionCount = parseInt(
          document.getElementById("collectionCount").value
        );
        const nodeSetPerCollection = parseInt(
          document.getElementById("nodeSetPerCollection").value
        );
        const nodesPerSet = parseInt(
          document.getElementById("nodesPerSet").value
        );

        // ç»˜åˆ¶é›†åˆä½“ã€èŠ‚ç‚¹é›†åˆå’Œå­èŠ‚ç‚¹
        const collections = drawCollections(
          collectionCount,
          nodeSetPerCollection,
          nodesPerSet
        );

        // ç»˜åˆ¶æ±‡æµç‚¹å’Œè¿æ¥
        drawConvergenceNodes(collections, nodesPerSet);

        // æ›´æ–°èŠ‚ç‚¹é›†åˆåˆ†ç»„ä¿¡æ¯
        updateNodeSetGroups(collections, nodesPerSet);

        // æ›´æ–°è·¨æ¥é…ç½®ä¸‹æ‹‰æ¡†çš„æ˜¾ç¤º
        updateCrossConnectionDropdowns();

        // æ›´æ–°æ±‡æµç‚¹ä¸å­èŠ‚ç‚¹çš„è¿æ¥å…³ç³»
        updateConvergenceConnections(collections, nodesPerSet);
      }

      // åˆ›å»ºè·¨æ¥é…ç½®UI
      function createCrossConnectionUI(collectionCount, nodesPerSet) {
        crossConnectionContainer.innerHTML = "";
        crossConnections = [];

        for (let i = 0; i < collectionCount; i++) {
          const group = document.createElement("div");
          group.className = "cross-connection-group";

          const label = document.createElement("label");
          label.textContent = `è·¨æ¥ç»„ ${i + 1}:`;
          group.appendChild(label);

          const container = document.createElement("div");
          container.className = "cross-connection-container";
          container.id = `crossConnectionGroup${i}`;

          // æ·»åŠ ä¸‹æ‹‰æ¡†
          for (let j = 0; j < collectionCount; j++) {
            if (j > 0) {
              const plus = document.createElement("span");
              plus.className = "plus-sign";
              plus.textContent = "+";
              container.appendChild(plus);
            }

            const select = document.createElement("select");
            select.className = "cross-connection-select";
            select.dataset.group = i;
            select.dataset.index = j;
            select.disabled = j > 0; // é»˜è®¤ç¦ç”¨åç»­ä¸‹æ‹‰æ¡†

            // æ·»åŠ é»˜è®¤é€‰é¡¹
            const defaultOption = document.createElement("option");
            defaultOption.value = "";
            defaultOption.textContent = " è¯·é€‰æ‹© ";
            select.appendChild(defaultOption);

            // æ·»åŠ æ±‡æµç‚¹é€‰é¡¹
            for (let k = 0; k < collectionCount * nodesPerSet; k++) {
              const option = document.createElement("option");
              option.value = k + 1;
              option.textContent = `#${k + 1}`;
              select.appendChild(option);
            }

            select.addEventListener("change", handleCrossConnectionChange);
            container.appendChild(select);
          }

          group.appendChild(container);
          crossConnectionContainer.appendChild(group);
        }
      }

      // æ›´æ–°è·¨æ¥é…ç½®ä¸‹æ‹‰æ¡†æ˜¾ç¤º
      function updateCrossConnectionDropdowns() {
        const dropdowns = document.querySelectorAll(
          ".cross-connection-select"
        );
        dropdowns.forEach((dropdown) => {
          for (let i = 0; i < dropdown.options.length; i++) {
            const option = dropdown.options[i];
            if (option.value && renumberedPointsMap[option.value]) {
              // ä¿æŒå€¼ä¸å˜ï¼Œä½†æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬ä¸ºæ–°ç¼–å·
              option.textContent = `#${renumberedPointsMap[option.value]}`;
            } else if (option.value) {
              // å¦‚æœæ²¡æœ‰é‡æ–°ç¼–å·çš„æ˜ å°„ï¼Œä¿æŒåŸç¼–å·
              option.textContent = `#${option.value}`;
            }
          }

          // å¦‚æœå½“å‰å·²é€‰æ‹©çš„å€¼æœ‰é‡æ–°ç¼–å·ï¼Œæ›´æ–°æ˜¾ç¤ºä½†ä¸æ”¹å˜å€¼
          if (dropdown.value && renumberedPointsMap[dropdown.value]) {
            const selectedOption = dropdown.options[dropdown.selectedIndex];
            selectedOption.textContent = `#${renumberedPointsMap[dropdown.value]
              }`;
          }
        });
      }

      // å¤„ç†è·¨æ¥é…ç½®å˜åŒ–
      function handleCrossConnectionChange(e) {
        const select = e.target;
        const groupIndex = parseInt(select.dataset.group);
        const selectIndex = parseInt(select.dataset.index);
        const selectedValue = select.value;

        // æ›´æ–°è·¨æ¥é…ç½®çŠ¶æ€
        if (!crossConnections[groupIndex]) {
          crossConnections[groupIndex] = [];
        }

        if (selectedValue) {
          crossConnections[groupIndex][selectIndex] = parseInt(selectedValue);

          // å¯ç”¨ä¸‹ä¸€ä¸ªä¸‹æ‹‰æ¡†
          const nextSelect = document.querySelector(
            `.cross-connection-select[data-group="${groupIndex}"][data-index="${selectIndex + 1
            }"]`
          );
          if (nextSelect) {
            nextSelect.disabled = false;

            // æ›´æ–°ä¸‹ä¸€ä¸ªä¸‹æ‹‰æ¡†çš„é€‰é¡¹
            updateCrossConnectionOptions(groupIndex, selectIndex + 1);
          }
        } else {
          // æ¸…ç©ºå½“å‰åŠåç»­é€‰æ‹©
          for (
            let i = selectIndex;
            i < crossConnections[groupIndex].length;
            i++
          ) {
            crossConnections[groupIndex][i] = null;
            const nextSelect = document.querySelector(
              `.cross-connection-select[data-group="${groupIndex}"][data-index="${i}"]`
            );
            if (nextSelect) {
              nextSelect.value = "";
              if (i > selectIndex) {
                nextSelect.disabled = true;
              }
            }
          }
        }

        // é‡æ–°ç”Ÿæˆæ‹“æ‰‘å›¾
        generateTopology();
      }

      // æ›´æ–°è·¨æ¥é…ç½®é€‰é¡¹
      function updateCrossConnectionOptions(groupIndex, selectIndex) {
        const select = document.querySelector(
          `.cross-connection-select[data-group="${groupIndex}"][data-index="${selectIndex}"]`
        );
        if (!select) return;

        // è·å–å·²é€‰æ‹©çš„æ±‡æµç‚¹
        const selectedValues = [];
        for (let i = 0; i < selectIndex; i++) {
          if (crossConnections[groupIndex][i]) {
            selectedValues.push(crossConnections[groupIndex][i]);
          }
        }

        // è·å–é›†åˆä½“æ•°é‡å’Œæ¯ä¸ªé›†åˆä½“çš„æ±‡æµç‚¹æ•°
        const collectionCount = parseInt(
          document.getElementById("collectionCount").value
        );
        const nodesPerSet = parseInt(
          document.getElementById("nodesPerSet").value
        );

        // è·å–æœ€åä¸€ä¸ªé€‰æ‹©çš„æ±‡æµç‚¹çš„ä½ç½®ä¿¡æ¯
        const lastSelected = selectedValues[selectedValues.length - 1];
        const lastCollectionIndex = Math.floor(
          (lastSelected - 1) / nodesPerSet
        );
        const lastPositionIndex = (lastSelected - 1) % nodesPerSet;

        // æ¸…ç©ºé€‰é¡¹ï¼ˆä¿ç•™é»˜è®¤é€‰é¡¹ï¼‰
        while (select.options.length > 1) {
          select.remove(1);
        }

        // æ·»åŠ ç¬¦åˆæ¡ä»¶çš„é€‰é¡¹
        for (let i = 0; i < collectionCount; i++) {
          // è·³è¿‡å·²ç»é€‰æ‹©è¿‡çš„é›†åˆä½“
          const collectionSelected = selectedValues.some((val) => {
            const colIdx = Math.floor((val - 1) / nodesPerSet);
            return colIdx === i;
          });

          if (!collectionSelected) {
            const convergenceIndex = i * nodesPerSet + lastPositionIndex + 1;
            const option = document.createElement("option");
            option.value = convergenceIndex;
            option.textContent = `#${convergenceIndex}`;
            select.appendChild(option);
          }
        }
      }

      // ç»˜åˆ¶é›†åˆä½“
      function drawCollections(
        collectionCount,
        nodeSetPerCollection,
        nodesPerSet
      ) {
        const collections = [];
        const horizontalPadding = 80; // å¢åŠ æ°´å¹³è¾¹è·
        const collectionWidth =
          (canvas.width - horizontalPadding * 2) / collectionCount;
        const collectionHeight = 120;

        // é‡ç½®èŠ‚ç‚¹é›†åˆæ•°ç»„
        nodeSets = [];

        for (let c = 0; c < collectionCount; c++) {
          const collection = {
            x: horizontalPadding + c * collectionWidth,
            y: 80,
            width: collectionWidth - 40,
            height: collectionHeight,
            nodeSets: [],
          };

          // ç»˜åˆ¶é›†åˆä½“å¤–æ¡†
          ctx.strokeStyle = "#3498db";
          ctx.fillStyle = "rgba(52, 152, 219, 0.1)";
          ctx.lineWidth = 2;
          ctx.strokeRect(
            collection.x,
            collection.y,
            collection.width,
            collection.height
          );
          ctx.fillRect(
            collection.x,
            collection.y,
            collection.width,
            collection.height
          );

          // ç»˜åˆ¶é›†åˆä½“æ ‡ç­¾
          ctx.fillStyle = "#2c3e50";
          ctx.font = "bold 14px Arial";
          ctx.fillText(
            `åŠŸç‡æ± ğŸ—²${c + 1}`,
            collection.x + 10,
            collection.y - 10
          );

          // ç»˜åˆ¶èŠ‚ç‚¹é›†åˆ
          const nodeSetWidth = (collection.width - 6) / nodeSetPerCollection;
          const nodeSetHeight = 80;

          for (let s = 0; s < nodeSetPerCollection; s++) {
            // è®¡ç®—å…¨å±€èŠ‚ç‚¹é›†åˆç¼–å·
            const globalNodeSetIndex = nodeSets.length;

            const nodeSet = {
              x: collection.x + s * nodeSetWidth + 6,
              y: collection.y + 20,
              width: nodeSetWidth - 6,
              height: nodeSetHeight,
              nodes: [],
              globalIndex: globalNodeSetIndex, // å…¨å±€ç¼–å·
              collectionIndex: c, // æ‰€å±é›†åˆä½“ç´¢å¼•
              localIndex: s, // åœ¨é›†åˆä½“å†…çš„æœ¬åœ°ç´¢å¼•
            };

            // ç»˜åˆ¶èŠ‚ç‚¹é›†åˆå¤–æ¡†
            ctx.strokeStyle = "#2980b9";
            ctx.lineWidth = 2;
            ctx.strokeRect(
              nodeSet.x,
              nodeSet.y,
              nodeSet.width,
              nodeSet.height
            );

            // ç»˜åˆ¶èŠ‚ç‚¹é›†åˆæ ‡ç­¾ï¼ˆæ˜¾ç¤ºå…¨å±€ç¼–å·ï¼‰
            ctx.fillStyle = "#2c3e50";
            ctx.font = "12px Arial";
            ctx.fillText(
              `${globalNodeSetIndex + 1}`,
              nodeSet.x + 5,
              nodeSet.y - 5
            );

            // ç»˜åˆ¶å­èŠ‚ç‚¹
            const nodeSize = 20;
            const nodeSpacing =
              (nodeSet.width - 20) / Math.max(1, nodesPerSet - 1);

            for (let n = 0; n < nodesPerSet; n++) {
              const node = {
                x: nodeSet.x + 10 + n * nodeSpacing,
                y: nodeSet.y + 40,
                size: nodeSize,
                index: n + 1, // èŠ‚ç‚¹åœ¨èŠ‚ç‚¹é›†åˆä¸­çš„åºå·
              };

              // ç»˜åˆ¶å­èŠ‚ç‚¹
              ctx.fillStyle = "#3498db";
              ctx.fillRect(
                node.x - nodeSize / 2,
                node.y - nodeSize / 2,
                nodeSize,
                nodeSize
              );

              // ç»˜åˆ¶å­èŠ‚ç‚¹æ ‡ç­¾
              ctx.fillStyle = "white";
              ctx.font = "10px Arial";
              ctx.fillText(`${n + 1}`, node.x - 4, node.y + 4);

              nodeSet.nodes.push(node);
            }

            collection.nodeSets.push(nodeSet);
            nodeSets.push(nodeSet);
          }

          collections.push(collection);
        }

        return collections;
      }

      // ç»˜åˆ¶æ±‡æµç‚¹å’Œè¿æ¥
      function drawConvergenceNodes(collections, nodesPerSet) {
        const bendY = 220;
        const collectionCount = collections.length;

        // ç¡®å®šå“ªäº›æ±‡æµç‚¹è¢«è·¨æ¥
        const crossConnectionGroups = [];
        const isCrossConnected = new Set(); // è®°å½•æ‰€æœ‰è¢«è·¨æ¥çš„æ±‡æµç‚¹

        // å¤„ç†è·¨æ¥é…ç½®
        crossConnections.forEach((group, groupIndex) => {
          if (group && group.length > 0) {
            const validGroup = group.filter(
              (item) => item !== null && item !== undefined
            );
            if (validGroup.length > 0) {
              // è®°å½•è·¨æ¥ç»„
              crossConnectionGroups.push({
                points: validGroup,
                color:
                  crossConnectionColors[
                  groupIndex % crossConnectionColors.length
                  ],
                mainPoint: validGroup[0],
                groupIndex: groupIndex,
              });

              // è®°å½•æ‰€æœ‰è¢«è·¨æ¥çš„æ±‡æµç‚¹
              validGroup.forEach((point) => {
                isCrossConnected.add(point);
              });
            }
          }
        });

        // é¦–å…ˆç»˜åˆ¶è·¨æ¥çº¿ï¼ˆåœ¨æœ€åº•å±‚ï¼‰
        drawCrossConnectionLines(
          collections,
          nodesPerSet,
          crossConnectionGroups,
          bendY
        );

        // ç„¶åç»˜åˆ¶æ‰€æœ‰è¿æ¥åˆ°æ±‡æµç‚¹çš„çº¿æ®µ
        drawConvergenceConnections(
          collections,
          nodesPerSet,
          bendY,
          isCrossConnected,
          crossConnectionGroups
        );

        // æœ€åç»˜åˆ¶æ±‡æµç‚¹ï¼ˆåœ¨æœ€é¡¶å±‚ï¼‰
        drawConvergencePoints(
          collections,
          nodesPerSet,
          isCrossConnected,
          crossConnectionGroups
        );
      }

      // ç»˜åˆ¶è·¨æ¥çº¿ï¼ˆåœ¨æœ€åº•å±‚ï¼‰
      function drawCrossConnectionLines(
        collections,
        nodesPerSet,
        crossConnectionGroups,
        bendY
      ) {
        const collectionCount = collections.length;

        crossConnectionGroups.forEach((group) => {
          if (group.points.length > 1) {
            ctx.strokeStyle = group.color;
            ctx.lineWidth = 4;

            // ç»˜åˆ¶è·¨æ¥ç»„å†…æ‰€æœ‰æ±‡æµç‚¹ä¹‹é—´çš„è¿æ¥çº¿
            for (let i = 0; i < group.points.length; i++) {
              for (let j = i + 1; j < group.points.length; j++) {
                const point1Index = group.points[i];
                const point2Index = group.points[j];

                const point1 = calculateConvergencePointPosition(
                  collections,
                  nodesPerSet,
                  point1Index,
                  group.groupIndex,
                  crossConnectionGroups.length
                );
                const point2 = calculateConvergencePointPosition(
                  collections,
                  nodesPerSet,
                  point2Index,
                  group.groupIndex,
                  crossConnectionGroups.length
                );

                if (point1 && point2) {
                  ctx.beginPath();
                  ctx.moveTo(point1.x, point1.y);
                  ctx.lineTo(point2.x, point2.y);
                  ctx.stroke();
                }
              }
            }
          }
        });
      }

      // ç»˜åˆ¶è¿æ¥åˆ°æ±‡æµç‚¹çš„çº¿æ®µ
      function drawConvergenceConnections(
        collections,
        nodesPerSet,
        bendY,
        isCrossConnected,
        crossConnectionGroups
      ) {
        const collectionCount = collections.length;

        for (let c = 0; c < collectionCount; c++) {
          const collection = collections[c];
          const convergenceSpacing = collection.width / (nodesPerSet + 1);

          for (let i = 0; i < nodesPerSet; i++) {
            const convergenceIndex = c * nodesPerSet + i + 1;

            // ç¡®å®šæ±‡æµç‚¹æ˜¯å¦ä¸ºè·¨æ¥æ±‡æµç‚¹
            const isCrossConvergence = isCrossConnected.has(convergenceIndex);

            // è®¡ç®—æ±‡æµç‚¹ä½ç½®
            let groupIndex = -1;
            if (isCrossConvergence) {
              for (const group of crossConnectionGroups) {
                if (group.points.includes(convergenceIndex)) {
                  groupIndex = group.groupIndex;
                  break;
                }
              }
            }

            const convergenceNode = calculateConvergencePointPosition(
              collections,
              nodesPerSet,
              convergenceIndex,
              groupIndex,
              crossConnectionGroups.length
            );

            // ç¡®å®šæ±‡æµç‚¹é¢œè‰²
            let color;
            if (isCrossConvergence) {
              // æ‰¾åˆ°å¯¹åº”çš„è·¨æ¥ç»„é¢œè‰²
              for (const group of crossConnectionGroups) {
                if (group.points.includes(convergenceIndex)) {
                  color = group.color;
                  break;
                }
              }
            } else {
              color =
                convergenceColors[
                convergenceIndex % convergenceColors.length
                ];
            }

            // ç»˜åˆ¶è¿æ¥åˆ°æ¯ä¸ªèŠ‚ç‚¹é›†åˆçš„ç¬¬iä¸ªèŠ‚ç‚¹
            collection.nodeSets.forEach((nodeSet) => {
              if (i < nodeSet.nodes.length) {
                const node = nodeSet.nodes[i];

                // ç»˜åˆ¶å‚ç›´å‘ä¸‹çš„çº¿æ®µ
                ctx.strokeStyle = color;
                ctx.lineWidth = isCrossConvergence ? 3 : 2;
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.x, bendY);
                ctx.stroke();

                // ç»˜åˆ¶è¿æ¥åˆ°æ±‡æµç‚¹çš„çº¿æ®µ
                ctx.beginPath();
                ctx.moveTo(node.x, bendY);
                ctx.lineTo(
                  convergenceNode.x,
                  convergenceNode.y - convergenceNode.size / 2
                );
                ctx.stroke();
              }
            });
          }
        }
      }

      // ç»˜åˆ¶æ±‡æµç‚¹ï¼ˆåœ¨æœ€é¡¶å±‚ï¼‰
      function drawConvergencePoints(
        collections,
        nodesPerSet,
        isCrossConnected,
        crossConnectionGroups
      ) {
        const collectionCount = collections.length;

        // è·å–æ‰€æœ‰æ±‡æµç‚¹ä½ç½®ï¼ŒæŒ‰ä»å·¦åˆ°å³æ’åº
        const allConvergencePoints = [];
        for (let c = 0; c < collectionCount; c++) {
          const collection = collections[c];
          const convergenceSpacing = collection.width / (nodesPerSet + 1);

          for (let i = 0; i < nodesPerSet; i++) {
            const convergenceIndex = c * nodesPerSet + i + 1;

            // ç¡®å®šæ±‡æµç‚¹æ˜¯å¦ä¸ºè·¨æ¥æ±‡æµç‚¹
            const isCrossConvergence = isCrossConnected.has(convergenceIndex);

            // è®¡ç®—æ±‡æµç‚¹ä½ç½®
            let groupIndex = -1;
            if (isCrossConvergence) {
              for (const group of crossConnectionGroups) {
                if (group.points.includes(convergenceIndex)) {
                  groupIndex = group.groupIndex;
                  break;
                }
              }
            }

            const convergenceNode = calculateConvergencePointPosition(
              collections,
              nodesPerSet,
              convergenceIndex,
              groupIndex,
              crossConnectionGroups.length
            );
            convergenceNode.originalIndex = convergenceIndex;
            convergenceNode.isCrossConnected = isCrossConvergence;

            // å¦‚æœæ˜¯è·¨æ¥æ±‡æµç‚¹ï¼Œæ‰¾åˆ°å®ƒæ‰€å±çš„ç»„å’Œä¸»èŠ‚ç‚¹
            if (isCrossConvergence) {
              for (const group of crossConnectionGroups) {
                if (group.points.includes(convergenceIndex)) {
                  convergenceNode.group = group;
                  convergenceNode.isMainNode =
                    convergenceIndex === group.mainPoint;
                  break;
                }
              }
            }

            allConvergencePoints.push(convergenceNode);
          }
        }

        // æŒ‰xåæ ‡ä»å·¦åˆ°å³æ’åº
        allConvergencePoints.sort((a, b) => a.x - b.x);

        // é‡æ–°ç¼–å·æ‰€æœ‰æ±‡æµç‚¹
        renumberedPointsMap = {};
        let nextAvailableNumber = 1;

        allConvergencePoints.forEach((point) => {
          if (point.isCrossConnected && !point.isMainNode) {
            // è·¨æ¥ç»„ä»èŠ‚ç‚¹ä¸åˆ†é…æ–°ç¼–å·
          } else {
            point.newIndex = nextAvailableNumber;
            renumberedPointsMap[point.originalIndex] = nextAvailableNumber;
            nextAvailableNumber++;
          }
        });

        // ç»˜åˆ¶æ‰€æœ‰æ±‡æµç‚¹
        allConvergencePoints.forEach((point) => {
          // ç¡®å®šæ±‡æµç‚¹é¢œè‰²
          let color;
          if (point.isCrossConnected) {
            color = point.group.color;
          } else {
            color =
              convergenceColors[
              point.originalIndex % convergenceColors.length
              ];
          }

          // ç»˜åˆ¶æ±‡æµç‚¹
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(point.x, point.y, point.size / 2, 0, Math.PI * 2);
          ctx.fill();

          // ç»˜åˆ¶æ±‡æµç‚¹æ ‡ç­¾ - ä»…æ˜¾ç¤ºä¸»èŠ‚ç‚¹ç¼–å·æˆ–ä¸è·¨æ¥çš„èŠ‚ç‚¹ç¼–å·
          ctx.fillStyle = "white";
          ctx.font = "bold 12px Arial";

          if (point.isCrossConnected) {
            // å¦‚æœæ˜¯è·¨æ¥ç»„çš„ä¸»èŠ‚ç‚¹ï¼Œæ˜¾ç¤ºä¸»èŠ‚ç‚¹çš„æ–°ç¼–å·
            if (point.isMainNode) {
              ctx.fillText(`#${point.newIndex}`, point.x - 10, point.y + 4);
            }
            // ä»èŠ‚ç‚¹ä¸æ˜¾ç¤ºç¼–å·
          } else {
            // éè·¨æ¥èŠ‚ç‚¹æ˜¾ç¤ºæ–°ç¼–å·
            ctx.fillText(`#${point.newIndex}`, point.x - 10, point.y + 4);
          }
        });
      }

      // è®¡ç®—æ±‡æµç‚¹ä½ç½®
      function calculateConvergencePointPosition(
        collections,
        nodesPerSet,
        convergenceIndex,
        groupIndex,
        crossConnectionGroupCount
      ) {
        const collectionIndex = Math.floor(
          (convergenceIndex - 1) / nodesPerSet
        );
        const positionIndex = (convergenceIndex - 1) % nodesPerSet;
        const collection = collections[collectionIndex];
        const convergenceSpacing = collection.width / (nodesPerSet + 1);

        // ç¡®å®šæ±‡æµç‚¹çš„å‚ç›´ä½ç½®
        let convergenceY;
        if (groupIndex >= 0) {
          // è·¨æ¥æ±‡æµç‚¹ï¼šåœ¨ä¸‹æ–¹ï¼Œä»320å¼€å§‹ï¼Œæ¯ç»„é—´éš”40åƒç´ 
          convergenceY = 320 + groupIndex * 40;
        } else {
          // éè·¨æ¥æ±‡æµç‚¹ï¼šåœ¨ä¸Šæ–¹
          convergenceY = 280;
        }

        return {
          x: collection.x + (positionIndex + 1) * convergenceSpacing,
          y: convergenceY,
          size: 25,
          originalIndex: convergenceIndex,
          isCrossConnected: groupIndex >= 0,
        };
      }

      // æ›´æ–°èŠ‚ç‚¹é›†åˆåˆ†ç»„ä¿¡æ¯
      function updateNodeSetGroups(collections, nodesPerSet) {
        // æ¸…ç©ºä¹‹å‰çš„åˆ†ç»„
        window.nodeSetGroups = {};

        // ç¡®å®šå“ªäº›æ±‡æµç‚¹è¢«è·¨æ¥
        const crossConnectionGroups = [];
        const isCrossConnected = new Set();

        // å¤„ç†è·¨æ¥é…ç½®
        crossConnections.forEach((group, groupIndex) => {
          if (group && group.length > 0) {
            const validGroup = group.filter(
              (item) => item !== null && item !== undefined
            );
            if (validGroup.length > 0) {
              // è®°å½•è·¨æ¥ç»„
              crossConnectionGroups.push({
                points: validGroup,
                mainPoint: validGroup[0],
                groupIndex: groupIndex,
              });

              // è®°å½•æ‰€æœ‰è¢«è·¨æ¥çš„æ±‡æµç‚¹
              validGroup.forEach((point) => {
                isCrossConnected.add(point);
              });
            }
          }
        });

        // ä¸ºæ¯ä¸ªæ±‡æµç‚¹åˆ›å»ºåˆ†ç»„
        for (let c = 0; c < collections.length; c++) {
          for (let i = 0; i < nodesPerSet; i++) {
            const convergenceIndex = c * nodesPerSet + i + 1;

            // ç¡®å®šæ±‡æµç‚¹æ˜¯å¦ä¸ºè·¨æ¥æ±‡æµç‚¹
            const isCrossConvergence = isCrossConnected.has(convergenceIndex);

            // å¦‚æœæ˜¯è·¨æ¥æ±‡æµç‚¹ï¼Œæ‰¾åˆ°å®ƒæ‰€å±çš„ç»„å’Œä¸»èŠ‚ç‚¹
            let mainConvergenceIndex = convergenceIndex;
            if (isCrossConvergence) {
              for (const group of crossConnectionGroups) {
                if (group.points.includes(convergenceIndex)) {
                  mainConvergenceIndex = group.mainPoint;
                  break;
                }
              }
            }

            // å¦‚æœè¿™ä¸ªåˆ†ç»„è¿˜ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
            if (!window.nodeSetGroups[mainConvergenceIndex]) {
              window.nodeSetGroups[mainConvergenceIndex] = [];
            }

            // å°†è¿æ¥åˆ°è¿™ä¸ªæ±‡æµç‚¹çš„æ‰€æœ‰èŠ‚ç‚¹é›†åˆæ·»åŠ åˆ°åˆ†ç»„ä¸­
            collections[c].nodeSets.forEach((nodeSet) => {
              window.nodeSetGroups[mainConvergenceIndex].push(
                nodeSet.globalIndex
              );
            });
          }
        }

        // å»é™¤é‡å¤çš„èŠ‚ç‚¹é›†åˆï¼ˆå¦‚æœæœ‰ï¼‰
        for (const convergenceIndex in window.nodeSetGroups) {
          window.nodeSetGroups[convergenceIndex] = [
            ...new Set(window.nodeSetGroups[convergenceIndex]),
          ];
        }
      }

      // æ›´æ–°æ±‡æµç‚¹ä¸å­èŠ‚ç‚¹çš„è¿æ¥å…³ç³»
      function updateConvergenceConnections(collections, nodesPerSet) {
        convergenceConnections = [];

        // ç¡®å®šå“ªäº›æ±‡æµç‚¹è¢«è·¨æ¥
        const crossConnectionGroups = [];
        const isCrossConnected = new Set();

        // å¤„ç†è·¨æ¥é…ç½®
        crossConnections.forEach((group, groupIndex) => {
          if (group && group.length > 0) {
            const validGroup = group.filter(
              (item) => item !== null && item !== undefined
            );
            if (validGroup.length > 0) {
              // è®°å½•è·¨æ¥ç»„
              crossConnectionGroups.push({
                points: validGroup,
                mainPoint: validGroup[0],
                groupIndex: groupIndex,
              });

              // è®°å½•æ‰€æœ‰è¢«è·¨æ¥çš„æ±‡æµç‚¹
              validGroup.forEach((point) => {
                isCrossConnected.add(point);
              });
            }
          }
        });

        // éå†æ¯ä¸ªæ±‡æµç‚¹
        for (let c = 0; c < collections.length; c++) {
          for (let i = 0; i < nodesPerSet; i++) {
            const originalConvergenceIndex = c * nodesPerSet + i + 1;

            // ç¡®å®šæ±‡æµç‚¹æ˜¯å¦ä¸ºè·¨æ¥æ±‡æµç‚¹
            const isCrossConvergence = isCrossConnected.has(
              originalConvergenceIndex
            );

            // è·å–é‡æ–°ç¼–å·åçš„æ±‡æµç‚¹ç¼–å·
            let convergenceNumber;
            if (isCrossConvergence) {
              // å¦‚æœæ˜¯è·¨æ¥æ±‡æµç‚¹ï¼Œæ‰¾åˆ°ä¸»èŠ‚ç‚¹çš„æ–°ç¼–å·
              for (const group of crossConnectionGroups) {
                if (group.points.includes(originalConvergenceIndex)) {
                  convergenceNumber =
                    renumberedPointsMap[group.mainPoint] || group.mainPoint;
                  break;
                }
              }
            } else {
              // éè·¨æ¥æ±‡æµç‚¹ç›´æ¥ä½¿ç”¨æ–°ç¼–å·
              convergenceNumber =
                renumberedPointsMap[originalConvergenceIndex] ||
                originalConvergenceIndex;
            }

            // éå†è¿æ¥åˆ°è¿™ä¸ªæ±‡æµç‚¹çš„æ‰€æœ‰èŠ‚ç‚¹é›†åˆ
            collections[c].nodeSets.forEach((nodeSet) => {
              // æ·»åŠ è¿æ¥å…³ç³»
              convergenceConnections.push({
                convergenceNumber: convergenceNumber,
                nodeIndex: i + 1, // å­èŠ‚ç‚¹åœ¨èŠ‚ç‚¹é›†åˆä¸­çš„åºå·
                nodeSetIndex: nodeSet.globalIndex + 1, // èŠ‚ç‚¹é›†åˆçš„ç¼–å·ï¼ˆä»1å¼€å§‹ï¼‰
              });
            });
          }
        }
      }
      function outputConvergenceConnectionsToFile() {
        var fileName = "pseudotopos.h";
        var fileContent = "";

        const collectionCount = parseInt(
          document.getElementById("collectionCount").value
        );
        const nodeSetPerCollection = parseInt(
          document.getElementById("nodeSetPerCollection").value
        );
        const nodesPerSet = parseInt(
          document.getElementById("nodesPerSet").value
        );


        let connection_lastindex = 0;
        // æŒ‰æ±‡æµç‚¹ç¼–å·ä»å°åˆ°å¤§æ’åº
        convergenceConnections.sort((a, b) => {
          return a.convergenceNumber - b.convergenceNumber;
        });

        // æŒ‰æ±‡æµç‚¹ç¼–å·åˆ†ç»„
        const groupedByConvergence = {};
        convergenceConnections.forEach((conn) => {
          if (!groupedByConvergence[conn.convergenceNumber]) {
            groupedByConvergence[conn.convergenceNumber] = [];
          }
          groupedByConvergence[conn.convergenceNumber].push(conn);
        });
        // å¤„ç†æ¯ä¸ªæ±‡æµç‚¹ç»„
        let keyValuePairs = [];
        for (const convergenceNumber in groupedByConvergence) {
          const connections = groupedByConvergence[convergenceNumber];
          if (connections.length > 0) {

            for (let i = 0; i < connections.length; i += nodeSetPerCollection) {
              const firstConn = connections[i];
              const contactorNumber = firstConn.nodeIndex + (firstConn.nodeSetIndex - 1) * nodesPerSet;
              const formattedPlugNumber = String(firstConn.convergenceNumber).padStart(2, '0');
              keyValuePairs.push(`{"u32gun${formattedPlugNumber}", ${contactorNumber}}`);
            }
            connection_lastindex = connections[0].convergenceNumber;
          }
        }
        for (let i = 0; i < keyValuePairs.length; i += 6) {
          const group = keyValuePairs.slice(i, i + 6);
          fileContent += `param_ref = ADD_KEYVALUE(${group.join(', ')});\r\n`;
        }

        fileContent += "uint32_t u32pwrnodes_max = " + collectionCount * nodeSetPerCollection + ";\r\n";
        fileContent += "uint32_t u32pwrcontactors_max = " + nodesPerSet * collectionCount * nodeSetPerCollection + ";\r\n";
        fileContent += "uint32_t u32pool_max = " + collectionCount + ";\r\n";
        fileContent += "uint32_t u32pwrguns_max = " + connection_lastindex + ";\r\n";
        fileContent += "param_ref = ADD_INTEGER(u32pwrnodes_max, u32pwrguns_max, u32pwrcontactors_max, u32pool_max);\r\n";
        downloadFile(fileContent, fileName);
      }
      // è¾“å‡ºèŠ‚ç‚¹é›†åˆåˆ†ç»„ä¿¡æ¯åˆ°æ–‡ä»¶
      function outputNodeSetGroupsToFile() {
        const collectionCount = parseInt(
          document.getElementById("collectionCount").value
        );
        const nodeSetPerCollection = parseInt(
          document.getElementById("nodeSetPerCollection").value
        );
        const nodesPerSet = parseInt(
          document.getElementById("nodesPerSet").value
        );

        let privateText = "";

        privateText +=
          '#ifdef PICKOUT_CONTACTANT\r\n#pragma message("structure and initialation deeds abt contactor introduced here...")\r\n';
        for (let i = 0; i < nodesPerSet; i++) {
          privateText += "CONTACTEE(" + (i + 1) + ")\r\n";
        }
        privateText += "#undef PICKOUT_CONTACTANT\r\n#endif\r\n\r\n";
        privateText +=
          '#ifdef PICKOUT_MUTUALREF\r\n#pragma message("compiling nodes heuristic linkage ...")\r\n';

        // æŒ‰æ±‡æµç‚¹ç¼–å·ä»å°åˆ°å¤§æ’åº
        convergenceConnections.sort((a, b) => {
          return a.convergenceNumber - b.convergenceNumber;
        });

        // æŒ‰æ±‡æµç‚¹ç¼–å·åˆ†ç»„
        const groupedByConvergence = {};
        convergenceConnections.forEach((conn) => {
          if (!groupedByConvergence[conn.convergenceNumber]) {
            groupedByConvergence[conn.convergenceNumber] = [];
          }
          groupedByConvergence[conn.convergenceNumber].push(conn);
        });
        let connection_lastindex = 0;
        // å¤„ç†æ¯ä¸ªæ±‡æµç‚¹ç»„
        for (const convergenceNumber in groupedByConvergence) {
          const connections = groupedByConvergence[convergenceNumber];

          // ç¬¬ä¸€ä¸ªè¿æ¥ä½¿ç”¨æ ‡å‡†æ ¼å¼
          if (connections.length > 0) {
            const firstConn = connections[0];
            privateText += `CONN_NODE(${firstConn.convergenceNumber}, ${firstConn.nodeIndex}, ${firstConn.nodeSetIndex})\r\n`;
            connection_lastindex = firstConn.convergenceNumber;
          }

          // åç»­è¿æ¥æ·»åŠ å‰ä¸€ä¸ªèŠ‚ç‚¹é›†åˆç¼–å·ä½œä¸ºå‚æ•°
          for (let i = 1; i < connections.length; i++) {
            const conn = connections[i];
            const prevNodeSetIndex = connections[i - 1].nodeSetIndex;
            privateText += `CONN_NODE(${conn.convergenceNumber}, ${conn.nodeIndex}, ${conn.nodeSetIndex}, ${prevNodeSetIndex})\r\n`;
          }
        }

        privateText += "#undef PICKOUT_MUTUALREF\r\n#endif\r\n\r\n";
        //è¾“å‡ºé¢„å®šä¹‰
        let cnt = 0;
        let publicText = "#pragma once\r\n\r\n";

        publicText += "#define SUBNODES_PER_POOL  " + nodeSetPerCollection + "\r\n";

        publicText += "#define CONTACTORS_PER_NODE  " + nodesPerSet + "\r\n";

        publicText +=
          "#define MAX_PLUGIN_NUM  " + connection_lastindex + "\r\n\r\n";
        publicText += "typedef enum{\r\nPWRPOOL_UNKNOWN = 0,\r\n";
        for (cnt = 0; cnt < collectionCount; cnt++) {
          publicText += "PWRPOOL" + (cnt + 1) + ",\r\n";
        }
        publicText +=
          "PWRPOOL_MAX=PWRPOOL" + cnt + "\r\n}PWRPOOL_ID;\r\n\r\n";
        publicText += "typedef enum{\r\nPWRNODE_UNKNOWN = 0,\r\n";
        for (cnt = 0; cnt < collectionCount * nodeSetPerCollection; cnt++) {
          publicText +=
            "PWRNODE" +
            (Math.floor(cnt / nodeSetPerCollection) + 1) +
            "_" +
            ((cnt % nodeSetPerCollection) + 1) +
            ",\r\n";
        }
        cnt = cnt - 1;
        publicText +=
          "PWRNODE_MAX=PWRNODE" +
          (Math.floor(cnt / nodeSetPerCollection) + 1) +
          "_" +
          ((cnt % nodeSetPerCollection) + 1) +
          "\r\n}PWRNODE_ID;\r\n\r\n";

        publicText += "typedef enum{\r\nCONTACTOR_UNKNOWN = 0,\r\n";
        for (
          cnt = 0;
          cnt < collectionCount * nodeSetPerCollection * nodesPerSet;
          cnt++
        ) {
          publicText +=
            "CONTACTOR" +
            (Math.floor(cnt / (nodeSetPerCollection * nodesPerSet)) + 1) +
            "_" +
            Math.floor(
              (cnt % (nodeSetPerCollection * nodesPerSet)) / nodesPerSet + 1
            ) +
            "_" +
            ((cnt % nodesPerSet) + 1) +
            ",\r\n";
        }
        cnt = cnt - 1;
        publicText +=
          "CONTACTOR_MAX=CONTACTOR" +
          (Math.floor(cnt / (nodeSetPerCollection * nodesPerSet)) + 1) +
          "_" +
          Math.floor(
            (cnt % (nodeSetPerCollection * nodesPerSet)) / nodesPerSet + 1
          ) +
          "_" +
          ((cnt % nodesPerSet) + 1) +
          "\r\n}CONTACTOR_ID;\r\n\r\n";
        // åˆ›å»ºå¹¶ä¸‹è½½ config_private.h
        downloadFile(privateText, "config_private.h");

        // åˆ›å»ºå¹¶ä¸‹è½½ config_public.h
        downloadFile(publicText, "config_public.h");
      }

      // é€šç”¨çš„æ–‡ä»¶ä¸‹è½½å‡½æ•°
      function downloadFile(content, filename) {
        // åˆ›å»ºBlobå¯¹è±¡
        const blob = new Blob([content], { type: "text/plain" });

        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.style.display = "none";

        // æ·»åŠ åˆ°æ–‡æ¡£å¹¶è§¦å‘ç‚¹å‡»
        document.body.appendChild(a);
        a.click();

        // æ¸…ç†
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(a.href);
        }, 100);
      }
      // åˆå§‹åŒ–
      function init() {
        // åˆå§‹ç”Ÿæˆæ‹“æ‰‘å›¾
        generateTopology();

        // åˆå§‹åˆ›å»ºè·¨æ¥é…ç½®UI
        const collectionCount = parseInt(
          document.getElementById("collectionCount").value
        );
        const nodesPerSet = parseInt(
          document.getElementById("nodesPerSet").value
        );
        createCrossConnectionUI(collectionCount, nodesPerSet);

        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        document
          .getElementById("collectionCount")
          .addEventListener("change", function () {
            const collectionCount = parseInt(this.value);
            const nodesPerSet = parseInt(
              document.getElementById("nodesPerSet").value
            );
            createCrossConnectionUI(collectionCount, nodesPerSet);
            generateTopology();
          });

        document
          .getElementById("nodeSetPerCollection")
          .addEventListener("change", generateTopology);
        document
          .getElementById("nodesPerSet")
          .addEventListener("change", function () {
            const collectionCount = parseInt(
              document.getElementById("collectionCount").value
            );
            const nodesPerSet = parseInt(this.value);
            createCrossConnectionUI(collectionCount, nodesPerSet);
            generateTopology();
          });

        // æ·»åŠ è¾“å‡ºæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        outputButton.addEventListener("click", outputConvergenceConnectionsToFile);
      }

      // å¯åŠ¨åº”ç”¨
      init();
    });
  </script>
</body>

</html>