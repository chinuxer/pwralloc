#pragma once
#include "pdu_broker.h"
#define KEYSTRLEN 20

typedef struct
{
    size_t count;
    uint16_t crc;
    char text[];
} Verbose_TextPool;
typedef struct
{
    size_t count;
    char *var;
} Verbose;
typedef union
{
    uint32_t all;
    struct
    {
        uint32_t contactor : 24;
        uint32_t plug : 8;
    } id_of;
} Combo_Koinon;

#define COUNT_ARGS(...) COUNT_ARGS_IMPL(_, ##__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#define COUNT_ARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define EXT_KEYVALUE(str, ...) {#str, COUNT_ARGS(__VA_ARGS__), ##__VA_ARGS__}
#define COUNT_TYPE_ARGS(type, ...) \
    (sizeof((type[]){__VA_ARGS__}) / sizeof(type))

#ifdef __INSTANT__PARAM__
static const uint8_t aucCRCHi[] = {
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40};
static const uint8_t aucCRCLo[] = {
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03,
    0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
    0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C,
    0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
    0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
    0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
    0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE,
    0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17,
    0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30,
    0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
    0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35,
    0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
    0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
    0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B,
    0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
    0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24,
    0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21,
    0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6,
    0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
    0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
    0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8,
    0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
    0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD,
    0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2,
    0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
    0x50, 0x90, 0x91, 0x51, 0x93, 0x53,
    0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
    0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
    0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
    0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59,
    0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
    0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E,
    0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47,
    0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
    0x41, 0x81, 0x80, 0x40};

#define macrocrc16(data, crc)                                 \
    do                                                        \
    {                                                         \
        crc = (aucCRCHi[(crc ^ data) & 0xff] ^ (crc >> 8)) |  \
              ((uint32_t)aucCRCLo[(crc ^ data) & 0xff] << 8); \
    } while (0)

Verbose_TextPool *oprt_TopoParam(Verbose_TextPool *param)
{
    static Verbose_TextPool *gparam = NULL;
    if (param)
    {
        gparam = param;
    }
    return gparam;
}

Verbose_TextPool *literalizing_keyvalue(const char *str, uint16_t members_nbr, ...)
{
    // Parameter validation
    if (NULL == str || members_nbr < 1)
    {
        return NULL;
    }
    // Get existing array structure
    Verbose_TextPool *textpool = oprt_TopoParam(NULL);
    size_t string_size = strnlen(str, KEYSTRLEN) + sizeof(""); // Include null terminator
    // Calculate new memory size
    size_t current_count = (textpool != NULL) ? textpool->count : 0;
    size_t additional_size = string_size + members_nbr * sizeof(uint16_t);
    size_t new_count = current_count + additional_size;
    size_t new_size = sizeof(Verbose_TextPool) + new_count * sizeof(char);
    // Memory reallocation
    Verbose_TextPool *new_textpool = realloc(textpool, new_size);
    if (new_textpool == NULL)
    {
        return NULL; // Memory allocation failed
    }
    // Copy key string
    char *dest = new_textpool->text + current_count;
    strncpy(dest, str, string_size);
    dest[string_size - 1] = '\0'; // Ensure string termination
    // Process key value variable arguments
    va_list args;
    va_start(args, members_nbr);
    // Calculate value storage location to avoid re-reading parameters
    uint16_t *pnum_dest = (uint16_t *)(dest + string_size);
    for (int cnt = 0; cnt < members_nbr; cnt++)
    {
        pnum_dest[cnt] = (uint16_t)va_arg(args, int);
    }
    va_end(args);
    // Update array count and register new array
    new_textpool->count = new_count;
    textpool = oprt_TopoParam(new_textpool);
    return textpool;
}

Verbose find_KeyValue_in_VerboseArray(const Verbose_TextPool *array, const char *key)
{
    if (!array || !key)
    {
        return (Verbose){0, NULL};
    }

    size_t key_len = strnlen(key, KEYSTRLEN);
    if (key_len == 0)
    {
        return (Verbose){0, NULL};
    }

    // Search through the text array for the key
    for (size_t i = 0; i < array->count;)
    {
        // Check if there's enough space for the key and at least 2 bytes for the value
        if (i + key_len + 1 + sizeof(uint16_t) > array->count)
        {
            break;
        }

        // Compare the current string with the key
        if (strncmp(array->text + i, key, key_len) == 0 &&
            *(array->text + i + key_len) == '\0')
        {
            // Found the key, extract the following 2 bytes as uint16_t
            uint16_t value = *(uint16_t *)(array->text + i + key_len + 1);
            return (Verbose){value, (char *)(array->text + i + key_len + 1 + sizeof(uint16_t))};
        }

        // Move to the next string: skip the string and the 2-byte value
        // First find the end of the current string
        size_t str_len = strnlen(array->text + i, array->count - i);
        i += str_len + 1 + sizeof(uint16_t); // +1 for null terminator, +2 for uint16_t value
    }

    return (Verbose){0, NULL}; // Key not found
}

static size_t insert_Joined_Node(Verbose matched_keyvalue, Combo_Koinon *container, uint32_t plug_id)
{
    // Insert the new node into the list
    size_t index = 0;
    for (int index = 0; index < matched_keyvalue.count; index++)
    {
        (container + index)->id_of.plug = plug_id;
        (container + index)->id_of.contactor = *(uint16_t *)(matched_keyvalue.var + index * sizeof(uint16_t));
    }
    return index;
}
void scan_KeyValue_of_PluginJoined(Combo_Koinon *container, size_t container_max, const Verbose_TextPool *array, uint32_t plug_id)
{
    if (!container || !array || !plug_id)
    {
        return;
    }
    size_t offset = 0;
    char key[KEYSTRLEN];
    for (size_t i = 0; i < POOL_MAX * CONTACTORS_PER_NODE; i++)
    {
        snprintf(key, sizeof(key), "u32gun%02d", plug_id);
        size_t key_len = strnlen(key, KEYSTRLEN);
        const char *ptr = array->text;
        Verbose match = find_KeyValue_in_VerboseArray(array, key);

        if (offset >= container_max)
        {
            break;
        }

        offset += insert_Joined_Node(match, container + offset, plug_id);
    }

    return;
}

#define IS_CHAR(c) _Generic((c), char *: 1, signed char *: 1, unsigned char *: 1, default: 0)

#define PICKOUT_KEYVALUE(param, token) ({uint32_t val=find_KeyValue(param,token); val; })

bool serialize_Download(Verbose_TextPool *param_array)
{

    if (!param_array)
    {
        return false;
    }
    uint16_t crc = 0xFFFF;
    for (size_t i = 0; i < param_array->count * sizeof(char); i++)
    {
        macrocrc16(*((uint8_t *)(param_array->text) + i), crc);
    }
    param_array->crc = crc;
    printf("Calculated CRC16: 0x%04X\n", crc);
    // Serial.write((uint8_t *)param_array, param_array->count * sizeof(KeyValue_Pair) + sizeof(uint16_t));
    return true;
}

bool deserialize_Upload(const void *data)
{
}
#else
bool serialize_Download(Verbose_TextPool *param_array);
bool deserialize_Upload(const void *data);
Verbose_TextPool *literalizing_keyvalue(const char *str, uint16_t members_nbr, ...);
#endif
